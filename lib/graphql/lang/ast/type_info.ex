
defmodule GraphQL.Lang.AST.TypeInfo do
  @moduledoc ~S"""
  TypeInfo maintains type metadata pertaining to the current node of a query AST,
  and is generated by the TypeInfoVistor.

  The type information is made available to validation rules.
  """

  alias GraphQL.Util.Stack
  alias GraphQL.Type.List
  alias GraphQL.Type.NonNull
  alias GraphQL.Type.Introspection

  @behaviour Access
  defstruct schema: nil,
            type_stack: %Stack{},
            parent_type_stack: %Stack{},
            input_type_stack: %Stack{},
            field_def_stack: %Stack{},
            directive: nil,
            argument: nil

  @doc """
  Return the top of the type stack, or nil if empty.
  """
  def type(type_info), do: Stack.peek(type_info.type_stack)

  def named_type(type_info, type) do
    if type === %List{} || type === %NonNull{} do
      named_type(type_info, type.ofType)
    else
      type
    end
  end

  @doc """
  Return the top of the parent type stack, or nil if empty.
  """
  def parent_type(type_info) do
    Stack.peek(type_info.parent_type_stack)
  end

  @doc """
  Return the top of the field def stack, or nil if empty.
  """
  def field_def(type_info) do
    Stack.peek(type_info.field_def_stack)
  end

  def find_field_def(schema, parent_type, field_node) do
    name = String.to_atom(field_node.name.value)
    cond do
      name == Introspection.meta(:schema)[:name] && schema.query == parent_type ->
        Introspection.meta(:schema)
      name == Introspection.meta(:type)[:name] && schema.query == parent_type ->
        Introspection.meta(:type)
      name == Introspection.meta(:typename)[:name] ->
        Introspection.meta(:typename)
      parent_type.__struct__ == GraphQL.Type.ObjectType || parent_type.__struct__ == GraphQL.Type.Interface ->
        # FIXME: this "function or map" logic is repeated in the executor. DRY IT UP.
        if is_function(parent_type.fields) do
          parent_type.fields.()[name]
        else
          parent_type.fields[name]
        end
      true ->
        nil
    end
  end
end
